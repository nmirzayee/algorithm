Problem Understanding

Given strings t (text) and p (pattern).

Find all occurrences of p in t.

Output:

Number of occurrences

1-based indices of occurrences

Requirement: Use Knuth-Morris-Pratt (KMP) algorithm.

Step 1: Build Prefix Function (pi-array)

pi[i] = length of the longest proper prefix of p[:i+1] which is also a suffix.

Helps to skip characters in the text during mismatches.

Python Function for Prefix Array
def compute_pi(p):
    n = len(p)
    pi = [0] * n
    for i in range(1, n):
        j = pi[i-1]
        while j > 0 and p[i] != p[j]:
            j = pi[j-1]
        if p[i] == p[j]:
            j += 1
        pi[i] = j
    return pi

Step 2: KMP Search

Iterate through t:

Track j = length of current matched prefix

On mismatch, jump using pi[j-1]

On match of full pattern (j == len(p)), record occurrence

def kmp_search(t, p):
    pi = compute_pi(p)
    n, m = len(t), len(p)
    j = 0
    occurrences = []

    for i in range(n):
        while j > 0 and t[i] != p[j]:
            j = pi[j-1]
        if t[i] == p[j]:
            j += 1
        if j == m:
            occurrences.append(i - m + 2)  # 1-based index
            j = pi[j-1]
    return occurrences

Step 3: Complete Solution
def solve():
    t = input().strip()
    p = input().strip()

    occurrences = kmp_search(t, p)
    print(len(occurrences))
    if occurrences:
        print(*occurrences)

Step 4: Test Example

Input:

abacaba
aba


Output:

2
1 5


Explanation:

"aba" occurs starting at positions 1 ("aba") and 5 ("aba").

Step 5: Complexity

Building prefix array: O(m), m = len(p)

Searching in text: O(n), n = len(t)

Total: O(n + m) â†’ efficient for large strings.

This solution fully satisfies the KMP requirement and returns all occurrence indices correctly.

If you want, I can also draw a step-by-step KMP table and pointer movements for the example "abacaba", "aba" to visualize how it works.

Do you want me to do that?
