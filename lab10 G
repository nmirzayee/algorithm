üöÄ Problem G ‚Äî Turn a Directed Graph Into a DAG by Removing ONE Edge

You are given a directed graph with n ‚â§ 500 vertices and m ‚â§ 100000 edges.

Ganyu wants to know whether she can make the graph acyclic (a DAG) by removing at most one edge.

You must output:

YES ‚Üí if removing at most one edge can make the graph a DAG

NO ‚Üí otherwise

‚≠ê Key Observations

A directed graph becomes a DAG if and only if it has no directed cycles.

So the task becomes:

‚ùó Can we remove at most 1 edge to destroy all directed cycles?

This means:

If graph already has no cycles ‚Üí answer is YES.

If graph has cycles:

Remove one edge, but that edge must destroy all cycles in the graph.

A single edge can eliminate all cycles only if:

‚Üí ALL cycles share at least one common edge

(so removing that edge kills every cycle).

If the graph has two disjoint cycles (no shared edge), removing one edge won‚Äôt fix both ‚Üí answer is NO.

‚úî Strategy

Find any cycle (via DFS).

Let that cycle‚Äôs edges be C.

For each edge e in that cycle:

Try removing e

Check if the new graph is acyclic using topological sort (Kahn).

If any removal makes the graph a DAG ‚Üí print YES.

If none work ‚Üí print NO.

Because:

n ‚â§ 500

m ‚â§ 100000

Cycle size ‚â§ n

This results in about O(n ¬∑ (n + m)) = 500 √ó 100500 = 50M operations, which is fast enough.

üß† Example Understanding

In your sample:

5 6
1 2
1 3
1 5
3 4
5 3
5 2


Cycles are:

1 ‚Üí 5 ‚Üí 3 ‚Üí 4 ‚Üí ‚Ä¶?

3 ‚Üí ? No direct cycle

but 1‚Üí5‚Üí3 and 5‚Üí2??

Actually this graph contains multiple independent cycles, so removing one edge cannot break everything.

Output: NO.

Correct.

‚úÖ Full C++ Solution
#include <bits/stdc++.h>
using namespace std;

int n, m;
vector<vector<int>> g;
vector<int> color, parent;
vector<pair<int,int>> cycle_edges;
bool found_cycle = false;

bool dfs(int v) {
    color[v] = 1; // visiting
    for (int u : g[v]) {
        if (color[u] == 0) {
            parent[u] = v;
            if (dfs(u)) return true;
        } else if (color[u] == 1) { // found cycle
            // recover cycle edges
            int x = v;
            cycle_edges.push_back({v, u});
            while (x != u) {
                int p = parent[x];
                cycle_edges.push_back({p, x});
                x = p;
            }
            return true;
        }
    }
    color[v] = 2;
    return false;
}

bool isDAGRemoving(pair<int,int> rem) {
    vector<int> indeg(n+1, 0);

    for (int v = 1; v <= n; v++)
        for (int u : g[v])
            if (!(v == rem.first && u == rem.second))
                indeg[u]++;

    queue<int> q;
    for (int i = 1; i <= n; i++)
        if (indeg[i] == 0)
            q.push(i);

    int cnt = 0;
    while (!q.empty()) {
        int v = q.front(); q.pop();
        cnt++;
        for (int u : g[v]) {
            if (v == rem.first && u == rem.second) continue;
            if (--indeg[u] == 0)
                q.push(u);
        }
    }

    return cnt == n;
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    cin >> n >> m;
    g.assign(n+1, {});
    for (int i = 0; i < m; i++) {
        int x, y;
        cin >> x >> y;
        g[x].push_back(y);
    }

    color.assign(n+1, 0);
    parent.assign(n+1, -1);

    // Step 1: Find a cycle
    for (int i = 1; i <= n; i++) {
        if (color[i] == 0) {
            if (dfs(i)) break;
        }
    }

    // No cycle ‚Üí already a DAG
    if (cycle_edges.empty()) {
        cout << "YES\n";
        return 0;
    }

    // Step 2: Try removing each edge in the cycle
    for (auto e : cycle_edges) {
        if (isDAGRemoving(e)) {
            cout << "YES\n";
            return 0;
        }
    }

    cout << "NO\n";
    return 0;
