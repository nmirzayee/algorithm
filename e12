âœ… 1. What is the Problem?

The code is solving a classic graph problem:

Given a directed weighted graph (with N nodes and edges defined by an NÃ—N cost matrix), detect if there is a negative cycle.

If a negative cycle exists â†’ print YES, print the cycle, and its length.
If no negative cycle exists â†’ print NO.

This is a standard Bellmanâ€“Ford negative cycle detection problem.

âœ… 2. What algorithm is used?
âœ” The program uses Bellmanâ€“Ford algorithm to detect a negative cycle.

Bellmanâ€“Ford:

Relax all edges N times.

If on the N-th iteration any distance improves â†’ a negative cycle exists.

Then reconstruct the cycle using parent pointers.

This code runs Bellmanâ€“Ford starting from each vertex until a cycle is found.

âœ… 3. Input format according to the code
n                   # number of nodes
n lines each with n integers  # cost matrix


Every pair (i, j) forms an edge:

from i â†’ j

with cost = matrix[i][j]

This is a complete directed graph because every iâ†’j is included.

âœ… 4. Explanation of important parts of the code
ğŸ”¹ Struct Edge
struct Edge {
    int a, b, cost;
};


A directed edge from a â†’ b with weight cost.

ğŸ”¹ Reading the graph
for (i=0..n-1)
    for (j=0..n-1)
        read cost
        create edge iâ†’j


So the graph has nÂ² edges.

âœ… 5. How Bellmanâ€“Ford detects negative cycles
Step 1 â€” Initialize distances
vector<int> d(n, INF);
d[v] = 0;


Start Bellmanâ€“Ford from vertex v.

Step 2 â€” Relax all edges N times
for (i = 0; i < n; i++) {
    x = -1;
    for (edge in edges) {
        if (d[edge.a] < INF) {
            if (d[edge.b] > d[edge.a] + edge.cost) {
                d[edge.b] = d[edge.a] + edge.cost;
                p[edge.b] = edge.a;
                x = edge.b;
            }
        }
    }
}


If on the N-th iteration, x != -1, a negative cycle exists.

ğŸ”¥ 6. Cycle exists if last relaxation changed something
if (x == -1) cycle = false;
else cycle = true;


If x != -1, we found a vertex affected by a negative cycle.

ğŸ”¥ 7. Reconstructing the negative cycle

Important step:

int y = x;
for (int i = 0; i < n; i++) y = p[y];


Why?
Because x is reachable from a negative cycle, but not guaranteed to be inside the cycle.

After n parent jumps, y will be inside the actual cycle.

Then reconstruct:

vector<int> path;
for (int cur = y;; cur = p[cur]) {
    path.push_back(cur);
    if (cur == y && path.size() > 1) break;
}
reverse(path.begin(), path.end());


This produces the cycle in correct order.

ğŸ”¥ 8. Output

If cycle exists:

YES
cycle_length
cycle_nodes (1-based)


If not:

NO

âœ… 9. Why do we run Bellmanâ€“Ford from every node?

Because negative cycles may not be reachable from some starting vertices.

So the code does:

for each v from 0 to n-1:
    run Bellman-Ford starting at v
    if negative cycle found â†’ stop


Efficient because N â‰¤ ~500 normally in labs.

â­ 10. Final Summary
Algorithm used:

âœ” Bellmanâ€“Ford Negative Cycle Detection
âœ” Relax edges N times
âœ” If distance improves on N-th step â†’ cycle exists
âœ” Recover cycle using parent pointers

Works for:

âœ” directed graphs
âœ” negative edge weights
âœ” full cost matrix (nÃ—n)

Output:

Prints a negative cycle if found

Otherwise prints NO
