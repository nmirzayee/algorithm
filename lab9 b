def solve():
    P, k = input().split()
    k = int(k)
    S = input().strip()

    merge = P + "#" + S
    n = len(merge)
    pi = [0] * n

    for i in range(1, n):
        j = pi[i - 1]
        while j > 0 and merge[i] != merge[j]:
            j = pi[j - 1]
        if merge[i] == merge[j]:
            j += 1
        pi[i] = j

    L = len(P)
    count = 0

    for x in pi:
        if x == L:
            count += 1

    print("YES" if count >= k else "NO")
solve()

.

ğŸ”‘ Goal of the Problem

We have:

A password string P

A long text string S

An integer k

We must check:

ğŸ‘‰ Does P occur in S at least k times?

If yes â†’ print YES,
otherwise NO.

Occurrences may overlap.

ğŸ”¥ Why we use Prefix Function (KMP)?

We must find all occurrences of P inside S efficiently.

S can be very large (up to 10â¶ characters)

P can also be large

Counting by scanning repeatedly is too slow

Pythonâ€™s count() and find() won't count overlapping matches correctly

KMP prefix function is optimal:

ğŸŸ¢ Time complexity: O(|P| + |S|)
ğŸŸ¢ Works for overlapping matches
ğŸŸ¢ Fast enough for any input limits

ğŸ§  Prefix Function (Ï€-array) â€” What it represents?

For a string T,
pi[i] = length of the longest proper prefix of T
which is also a suffix ending at position i.

Example:
T = "abcab"
Ï€ = [0, 0, 0, 1, 2]

This means:

At index 4, "abcab" ends with "ab" â†’ prefix "ab" matches suffix "ab" â†’ pi=2

ğŸ¯ How does this help us find P in S?

We create a combined string:

T = P + '#' + S


Example:

P = "hello"
S = "helloThomashello"

T = "hello#helloThomashello"

Why add '#'?

It's a delimiter so P never accidentally overlaps with itself in the merge.

Ensures all matches in S are detected.

ğŸ” Core idea

When scanning T and computing Ï€-array:

ğŸ‘‰ If at any position i, Ï€[i] == len(P),
it means:

â­ A full copy of P ends here inside S.

So we count every such match.

ğŸ”„ Step-by-step simulation

Let:

P = "hello" â†’ length 5
S = "helloThomashelloJohnhello"

We build:

"hello#helloThomashelloJohnhello"


We compute Ï€ for the whole merged string.

During the Ï€ computation:

When Ï€[i] = 5
â†’ The suffix ending at i matches the prefix "hello"
â†’ So "hello" occurs ending at that position
â†’ Count occurrence

If we count â‰¥ k â†’ password is correct.

ğŸ§© Why does this match substring search exactly?

Because the prefix function tries to match:

P  
#  
S


It repeatedly compares characters from P to characters in S

If mismatch: uses the prefix values to "jump" quickly, avoiding re-checks

Whenever a full match is found, Ï€ becomes = len(P)

This is exactly how substring search is done in KMP.

ğŸ’¡ Example

Input:

hello 2
helloThomashello


Merged:

hello#helloThomashello


Ï€-array contains three indices where Ï€[i] = 5 â†’ matches "hello".

count = 3 â‰¥ 2
â†’ print YES

ğŸ§  Why does this find overlapping matches?

Example:
P = "aaa"
S = "aaaaa"

Matches at indices:

aaa
 aaa
  aaa


Prefix function naturally counts all these overlaps because:

It doesn't reset to zero after a match

It continues from pi[last]

This makes it better than naive search.

ğŸ Summary (simple version)

Build string: P + '#' + S

Compute Ï€-array.

Every time Ï€[i] == len(P),
a full occurrence of P ends at position i.

Count all such matches.

If count â‰¥ k â†’ YES, else NO.
