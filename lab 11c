âœ… WHAT THE PROGRAM DOES

You are given:

n â†’ number of cities

m â†’ number of possible roads

x â†’ multiplier for "big" roads

y â†’ multiplier for "small" roads

Each road can be one of:

"big" â†’ cost = base cost Ã— x

"small" â†’ cost = base cost Ã— y

"both" â†’ you can build either big or small road
â†’ the code adds two different edges to the graph.

The goal:

Connect all cities with the minimum total cost

This is exactly the Minimum Spanning Tree (MST) problem solved by Kruskalâ€™s algorithm.

âœ… EXPLANATION OF EACH PART
ðŸ”¹ 1. Disjoint Set Union (Union-Find)

This structure helps check whether two cities are already connected.

Constructor
parent[i] = i;
rank[i] = 0;


Each node is its own parent at the start.

findSet(v)

Path-compressed "find":

if (v != parent[v])
    parent[v] = findSet(parent[v]);
return parent[v];


Returns the representative (root) of the component containing v.

uniteSets(a, b)

Union by rank:

Find roots

Attach the smaller tree under the larger

Increase rank if both were equal

This ensures optimal merging:

if (rank[a] < rank[b]) swap(a, b);
parent[b] = a;
if (rank[a] == rank[b]) ++rank[a];

ðŸ”¹ 2. Graph Class

Stores:

number of cities

vector of edges
each stored as: (cost, (cityA, cityB))

addEdge
edges.emplace_back(cost, make_pair(cityA, cityB));


Allows adding edges with different costs.

ðŸ”¹ 3. Kruskalâ€™s Algorithm
sort(edges.begin(), edges.end());


Sort edges by increasing cost.

Create DSU to track components.

Loop through edges:
if (ds.findSet(cityA) != ds.findSet(cityB)) {
    totalCost += cost;
    ds.uniteSets(cityA, cityB);
}


Meaning:

If adding this road does NOT create a cycle

Add its cost

Merge the two cities into the same component

This builds the Minimum Spanning Tree (MST).

ðŸ”¹ 4. Reading Input in main()
cin >> n >> m >> x >> y;


Then for each road:

string roadType;
int cityA, cityB, cost;
cin >> roadType >> cityA >> cityB >> cost;


Cities are converted to 0-based:

cityA - 1, cityB - 1

Cost rules:
Road Type	Added edge cost
big	cost Ã— x
small	cost Ã— y
both	cost Ã— x and cost Ã— y

So "both" adds two options:

graph.addEdge(cost*x, A, B);
graph.addEdge(cost*y, A, B);


Kruskal will later choose whichever is cheaper.

ðŸ”¹ 5. Output final MST cost
int totalCost = graph.kruskalMST();
cout << totalCost;

âœ… WHAT PROBLEM THIS SOLVES

This solves:

**Find the cheapest way to connect all cities,

when each road has two possible construction types (big/small),
each with different cost multipliers.**

Using Kruskal ensures:

no cycles

minimum possible cost

uses big or small road depending on which is cheaper

ðŸ”¥ FULL SUMMARY (VERY SHORT)

Program builds a weighted graph of cities.

Each road type changes its cost.

"both" roads create two edges with different costs.

Then it uses Kruskalâ€™s MST to find the minimum total cost to connect all cities.

DSU ensures no cycles when selecting roads
