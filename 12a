‚úÖ WHAT IS THIS PROBLEM? (ADS-Lab-12)

This is the Dynamic Floyd‚ÄìWarshall Reconstruction problem.

You are given:

‚úî A weighted matrix (distance matrix)
‚úî An order of adding vertices x[1], x[2], ..., x[n]

Each step:

Add vertex x[k] into the graph

Update all shortest paths using this vertex

Compute the maximum shortest path between all currently added vertices

Print the result

This is a standard algorithm used in Dynamically Constructed All-Pairs Shortest Paths.

‚ú® WHAT THE ALGORITHM REALLY DOES

Let the graph initially be empty.

On step k, you "activate" vertex:

v = x[k]
used[v] = true


Then run one step of Floyd‚ÄìWarshall:

for all i,j:
    dist[i][j] = min(dist[i][j], dist[i][v] + dist[v][j])


After that, compute:

max shortest path among all used vertices


And store the answer.

üîµ WHY THIS WORKS

Floyd‚ÄìWarshall normally does:

for k = 1..n:
  for i = 1..n:
    for j = 1..n:
       dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j])


This code does the same, but:

‚úî Vertices are processed in a custom order
‚úî After each vertex is processed, we record the answer

So effectively:

After processing 1st vertex ‚Üí shortest paths among active vertices

After processing 2 ‚Üí update paths

‚Ä¶ until all vertices added

This solves classic tasks like:

üîπ Adding nodes one by one
üîπ Recomputing all-pairs shortest paths
üîπ Logging maximum shortest path after each addition

This appears in many ACM/ICPC problems.

üîµ NOW THE DETAILED EXPLANATION OF THE CODE
Class MatrixProcessor
Data members:
int n;                // matrix size  
int matrix[501][501]; // adjacency matrix  
int x[501];           // order of adding vertices  
bool used[501];       // which vertices are active  
vector<int> ans;      // answers after each step

readInput()

Reads:

n

the distance matrix

the order x[i]

process()

This loops over steps:

Step k:

Mark vertex x[k] as used

Update matrix using Floyd-Warshall with vertex x[k]

Compute max shortest path among used vertices

Store it

updateMatrix(k)

Classic Floyd step:

dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j])


But run only for one vertex after each step.

calculateMax()

Find:

max shortest path among used vertices


Meaning:

max(dist[i][j]) for all used i,j

printResults()

Just prints all elements of ans.

‚≠ê FULL FLOW EXAMPLE (SMALL)**

Let‚Äôs suppose:

n = 3
matrix:
0 5 9
5 0 2
9 2 0

order x:
3 1 2

Step 1: add vertex 3

Used = {3}

Max path = 0
(ans = 0)

Step 2: add vertex 1

Used = {3,1}

Update shortest paths through vertex 1

Paths among {1,3}:
9 ‚Üí 9
Max = 9

Step 3: add vertex 2

Now Used = {1,2,3}

Shortest paths update through 2:

new shortest path 1‚Üî3 = 1‚Üí2‚Üí3 = 2+2 = 4

others remain same

Max = 5

Output:

0
9
5

‚≠ê CLEAN AND FINAL EXPLANATION CODE (same logic)
#include <bits/stdc++.h>
using namespace std;

class MatrixProcessor {
    static const int MAXN = 501;
    int n;
    int dist[MAXN][MAXN];
    int order[MAXN];
    bool active[MAXN];
    vector<int> answer;

public:
    void readInput() {
        cin >> n;

        for (int i = 1; i <= n; i++)
            for (int j = 1; j <= n; j++)
                cin >> dist[i][j];

        for (int i = 1; i <= n; i++)
            cin >> order[i];
    }

    void process() {
        memset(active, false, sizeof(active));

        for (int step = 1; step <= n; step++) {
            int k = order[step];

            active[k] = true;

            // Floyd update with vertex k
            for (int i = 1; i <= n; i++)
                for (int j = 1; j <= n; j++)
                    dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j]);

            answer.push_back(getMaxAmongActive());
        }
    }

    void printResults() {
        for (int v : answer)
            cout << v << "\n";
    }

private:
    int getMaxAmongActive() {
        int mx = 0;
        for (int i = 1; i <= n; i++)
            for (int j = 1; j <= n; j++)
                if (active[i] && active[j])
                    mx = max(mx, dist[i][j]);

        return mx;
    }
};

int main() {
    MatrixProcessor p;
    p.readInput();
    p.process();
    p.printResults();
}
