ğŸ”µ Problem Summary

You have an undirected graph with n vertices, m edges

Initially all vertices are black

Two types of queries:

Type 1: 1 x

Turn vertex x red.

Type 2: 2 x

Print distance from x to the nearest red vertex
If no red exists â†’ print -1

â— Important

We must answer many queries fast â€” doing BFS from x for each query = TLE.

We need an online dynamic BFS idea.

âœ… Correct Insight: Multi-Source BFS

Keep a queue of all red vertices.

Maintain:

dist[v] = distance from v to nearest red


Initially:

No red â†’ all dist = INF (or -1)

When a vertex becomes red (operation â— 1 x):

If it's already red â€” skip

Else:

Set dist[x] = 0

Push it into BFS queue

Then run incremental BFS:

While the BFS queue has items:

Try to relax distances of neighbours

Same idea as Dijkstra with all red nodes as sources, but edges are unweighted so BFS.

This guarantees each edge is processed at most once â†’ total time O(n + m).

ğŸ§  Algorithm
Initialization:
dist[i] = INF for all i
queue Q is empty

For each query:
âœ” Query type 1: 1 x
if dist[x] != 0:
    dist[x] = 0
    Q.push(x)
    run BFS update while possible

âœ” Query type 2: 2 x
if dist[x] is INF â†’ print -1
else â†’ print dist[x]

ğŸŒŸ WORKED EXAMPLE

Input:

5 4 7
1 2
2 3
3 4
4 5
2 1
1 1
2 1
2 2
2 5
1 3
2 5


Graph:
1â€”2â€”3â€”4â€”5

Queries:

2 1 â†’ no red yet â†’ -1

1 1 â†’ red = {1}

2 1 â†’ nearest red = itself â†’ 0

2 2 â†’ nearest red = 1 â†’ 1

2 5 â†’ dist = 4 â†’ 4

1 3 â†’ red = {1,3}, update BFS

2 5 â†’ closest red = 3 â†’ 2

Matches output.

âœ… C++ Code (Efficient: O(n + m + q))
#include <bits/stdc++.h>
using namespace std;

static const int INF = 1e9;

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    int n, m, q;
    cin >> n >> m >> q;

    vector<vector<int>> g(n + 1);
    for (int i = 0; i < m; i++) {
        int u, v;
        cin >> u >> v;
        g[u].push_back(v);
        g[v].push_back(u);
    }

    vector<int> dist(n + 1, INF);
    queue<int> bfs;

    while (q--) {
        int t, x;
        cin >> t >> x;

        if (t == 1) {
            if (dist[x] != 0) {
                dist[x] = 0;
                bfs.push(x);

                while (!bfs.empty()) {
                    int v = bfs.front(); bfs.pop();
                    for (int u : g[v]) {
                        if (dist[u] > dist[v] + 1) {
                            dist[u] = dist[v] + 1;
                            bfs.push(u);
                        }
                    }
                }
            }

        } else {  // Query type 2
            if (dist[x] == INF) cout << -1 << "\n";
            else cout << dist[x] << "\n";
        }
    }

    return 0;
}

ğŸŸ¢ Runs in linear time, perfect for large constraints.
