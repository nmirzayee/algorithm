âœ… WHAT THE CODE IS DOING

You are given:

vertexCount â€” number of vertices (1 to n)

edgeCount â€” number of edges

a graph described by edges.

But instead of building the graph normally, the algorithm adds vertices one by one in reverse order (from n to 1) and tracks:

ðŸ‘‰ How many connected components exist after each vertex is added?

This is a known trick for problems like:

"Offline dynamic connectivity"

"How many components after removing nodes?"

"Reverse delete + DSU fix"

âœ… BREAKDOWN OF THE CODE
1. DSU (Disjoint Set Union)

You have:

int dsuParent[MAX_VERTICES], dsuRank[MAX_VERTICES];


initializeDSU() sets each node as its own parent:

dsuParent[i] = i;
dsuRank[i] = 1;

2. findRoot() â€” Path compression
int findRoot(int v) {
    return (dsuParent[v] == v) ? v : (dsuParent[v] = findRoot(dsuParent[v]));
}


This:

Follows parents until root is found

Compresses the path â†’ makes future queries faster (almost O(1))

3. uniteSets() â€” Union by rank
bool uniteSets(int a, int b)


Finds roots

Merges smaller tree into larger

Increases rank when equal

Returns false if the nodes are already in the same set

Returns true if a union happened

ðŸ”¥ MAIN IDEA OF THE ALGORITHM

The key part:

for (int currentVertex = vertexCount; currentVertex >= 1; currentVertex--) {
    componentCount++;


We start with an empty graph (no vertices active).

Then we turn on vertices in reverse:

add vertex n
add vertex nâˆ’1
add vertex nâˆ’2
...


When we activate a vertex:

It forms its own connected component â†’ componentCount++

Then we check all edges from this vertex:

for (int neighbor : adjacencyList[currentVertex])


But we only consider neighbors that were already activated:

if (currentVertex < neighbor)


Why?

Because weâ€™re activating nodes from n â†’ 1, so:

If neighbor > currentVertex â†’ neighbor is already in graph

If neighbor < currentVertex â†’ neighbor isnâ€™t activated yet

If two active vertices are connected:

if (findRoot(currentVertex) != findRoot(neighbor)) {
    componentCount--;
    uniteSets(currentVertex, neighbor);
}


Meaning:

They belonged to two distinct components

After merging, total components reduce by 1

ðŸ“Œ 4. Store the result for each step
connectedComponents.push_back(componentCount);


Finally reverse the array because we added nodes backwards:

reverse(connectedComponents.begin(), connectedComponents.end());

ðŸ“Œ 5. Output format

The code prints:

Number of connected components after activating vertex 2,3,â€¦,n

Finally prints 0 for vertex 1 activation.

Why 0?

Because after all vertices added, the last stored value equals actual components â€” but the problem probably asks to print nâˆ’1 results and end with zero.

ðŸ§  SUMMARY (VERY SIMPLE)

This code:

Reads the graph.

Activates vertices from n down to 1.

Uses DSU to merge edges to already-activated neighbors.

Tracks the number of connected components at each step.

Reverses the result to match the correct order.

Prints it.

This is a classical reverse DSU dynamic connectivity solution â€” extremely efficient:

Time complexity: O((n + m) Î±(n))
(Almost linear)
